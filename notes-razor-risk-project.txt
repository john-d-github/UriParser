==================
Razor Risk project
==================

Project definition

	The purpose:
	
	This test is intended to provide some reflection on the following:

	·         How you go about design and development of a relatively small, isolated component;
	·         What aspects of software quality – such as Discoverability, Modularity, Efficiency, Testability, and so forth – you capture in your work, and at what stages;
	·         How you use source control;

	Our expectation is that this task should take not less than two and not more than ten hours cumulative work.

	The specification:
	
	You are requested to create a component, written in a language of your choice (though it must be one of C++, C#, Go, Java, Python, Ruby), that performs URI parsing, recording its evolution in a Git repository that you will create and email back (in archive form) for our perusal.
	The parser component should be able to identify all of the recognised components of a well-formed URI – scheme, user, password, host, port, path, query, fragment – and provide them to the caller in the form of a suitable abstraction.
	The parser component should communicate adequately to the caller upon receipt of malformed input.
	According to current requirements, the parser will not represent a performance bottleneck within the systems in which it will be used. As such, you are not required to focus your design and development efforts on exacting highest-possible performance above other aspects of quality. If you wish to comment on how your implementation and design might be adjusted to have higher runtime performance should the requirements change, that would be of interest to us.
	Given the problem-domain, a Test Driven Development (TDD) approach is recommended, but not required. Should you choose to follow a TDD-approach, the suite of tests may be deemed to be the component’s documentation.
	Whether or not you use TDD, each meaningful step of your work should be recorded in the repository.
	Please provide links to any reference material to which you refer.

 
Create a new git repo from an existing project

    Go into the directory containing the project.
    `git init .`
    `git add` to add all of the relevant files.
    Create .gitignore file. Use `git add .gitignore`, too.
    `git config user.email "jsdalzell@gmail.com"`
    `git config user.name "John Dalzell"`
    `git commit . -m "Initial working draft"`


Discoverability = (in relation to online content) the quality of being easy to find via a search engine, within an application, or on a website.
"a good way to gauge your discoverability is to type your name into Google"

http://synesis.com.au/publishing/xstl/xstlv1_prologue.pdf
Wilson, Matthew - Extended STL vol 1 (2007) p xxvii
Definition: Discoverability is how easy it is to understand a component in order to be able to use it.
Definition: Transparency is how easy it is to understand a component in order to be able to modify it.


URI defined in RFC 3986 (Jan 2005).
	scheme : [ // [ user : password @ ] host [ : port ] ] [ / ] path [ ? query ] [ # fragment ]
	Can be empty string - see RFC 3986 (2005) Section 4.1
	Example of IPv6 host: "file://[fe80::203:baff:fe5a:749d%1]/Documents/file"

	
class URI {
	string Scheme;
	string User; 
	string Password;
	string Host; 
	string Port; 
	string Path; 
	string Query; 
	string Fragment;
};
    
    
https://msdn.microsoft.com/en-us/library/aa287601(v=vs.71).aspx

	// Single-dimensional array (numbers).
	int[] n1 = new int[4] {2, 4, 6, 8};
	int[] n2 = new int[] {2, 4, 6, 8};
	int[] n3 = {2, 4, 6, 8};
	
	// Single-dimensional array (strings).
	string[] s1 = new string[3] {"John", "Paul", "Mary"};
	string[] s2 = new string[] {"John", "Paul", "Mary"};
	string[] s3 = {"John", "Paul", "Mary"};

	// Multidimensional array.
	int[,] n4 = new int[3, 2] { {1, 2}, {3, 4}, {5, 6} };
	int[,] n5 = new int[,] { {1, 2}, {3, 4}, {5, 6} };
	int[,] n6 = { {1, 2}, {3, 4}, {5, 6} };

	// Jagged array.
	int[][] n7 = new int[2][] { new int[] {2,4,6}, new int[] {1,3,5,7,9} };
	int[][] n8 = new int[][] { new int[] {2,4,6}, new int[] {1,3,5,7,9} };
	int[][] n9 = { new int[] {2,4,6}, new int[] {1,3,5,7,9} };


FSM transition matrix - initial draft

				:		not:	/			not/	?		not?	#			not#		EOS		notEOS
	initial																					final	scheme
	scheme		slash1	scheme																final
	slash1						slash2		path											final
	slash2						hostgroup	path											final
	path											query	path							final
	query															fragment	query		final
	fragment																	fragment	final
	final

	Sub-matrix for hostgroup

				not/		:		@		/		not@:/		not:	EOS
	hostgroup	lhs							path						final
	lhs						rhs		error1	path	lhs					final
	rhs						error2	host	path	rhs					final
	host					port								host	final		
	port		port						path						final
	error1
	error2
	
	Note: If host has a value, lhs = user, rhs = password
	Else, lhs = host, rhs = port

We need rules about what tokens to consume and what to ignore
/ @ : are ignored, the rest are consumed into next state.

Planning & research - 2 hours
Initial build - 2 hours
Debugging first draft - 2 hours

	Chgs to the FSM were easier than I thought
	Put the transition matrix in Excel spreadsheet

	http://user:pass@www.google.com/path:1234?id=1#frag=2 not separating host & path 
		Host = @www.google.com/path
	http://user:pass@www.google.com:1234/path/path2#frag not picking up fragment
		Path = /path/path2#frag
	http:/path/path2?query#frag not distinguishing betw relative & absolute path
		whether you have leading / or not, still get same value
		Path = path/path2


Debugging 2nd draft - 2 hours
Change the indexing of transition matrix etc from literals to enum's.
Although tedious, this did improve readability a lot.

	http://www.google.com:1234:5678 should give error
		Host = www.google.com12345678
		Port = :
	Sol`n: Typo in transition matrix
	
	States error1 & error2 not picking up all of the input after a parse error.
	Sol`n: Need to transition to themselves if notEOS


Introducing test case file 'uri-test-cases.txt' & validating against it - 3 hours

	Looks like state not being cleared properly as some state-values have extraneous text at the end
	Sol`n: Was appending the dummy EOS character '\0'.
	
	Not distinguishing between absolute path '/path' and relative path 'path' in some cases.
	Eg between `foo:xyz` and `foo:/xyz` ??
	Sol`n: Use internal state variable slash2 - if it captured a '/' and Host is blank, then we can assume absolute path & prepend '/' to Path 
	
	Should disregard trailing spaces as not semantically significant, but they trigger mismatch to expected result of test cases
	Action: For Path, trim trailing space and '/'
	
	Not stripping leading chars like : / ? #
	Sol`n: Add extra states to consume the leading char & jump straight to capture the "true" state
	I.e. pathTok, queryTok, fragTok, hostTok, rhsTok, portTok
	
	Not handling empty password in `ftp://anonymous:@public.server.com:22/public/data/file.txt`
	Sol`n: Need to capture the '@' in `rhsTok` state as well as in `rhs` state.
	
	'http://user@host/path?query' jumps to error state, but the rest of the properties are parsed oddly.

	'Error' field in uri-test-cases.txt' is being read in to the instance UriTestCase, but is not printed out in ToString().
	Seems to have disappeared by the time we call .ToString(). I just see "Error=" with no value.
	Sol`n: A bit embarrassing - the error message was actually on the previous record, not the record which mismatched!
	
	Make the properties in UriParser publicly readable but only writeable from within the class.
	Sol`n: `public string Scheme { get; private set; }` etc
	
	Error message returned from UriParser has no explanation - it just dumps the input URI from the point where parsing failed.
	Tarted up the error message UriParser returns to provide an explanation - the error state variables just capture input from where parse failed.
	
	Scheme is required but it accepts "www.google.com" - it places this in Scheme.
	Sol`n: Check `slash1` state - did it capture a ':'? If not, raise an error.

	
SUMMARY

	It was an interesting project. I wanted to try out a Finite State Machine (FSM) for this and it worked well I think.
	As shortcomings appeared, there were a few modifications that needed to be made to it and it was relatively easy to change.
	I approached testing in the way I'm used to - a suite of test cases which are applied end-to-end, rather than unit testing.
	The UriParser C# class library is called by the C# Windows Forms application UriParser_Client (the test harness).
	Tests can be via a set of test-cases or by entering a specific URI and parsing that.
	
	I spent a bit over the maximum 10 hours cumulative work, so I thought I better submit this now, even though there's a lot more I'd like to do with it.
	See "Razor Risk FSM.xls" for the 2 versions of the state transition matrix, and for the test cases.
	I copy-pasted the test cases into "UriParser_Client/uri-test-cases.txt" for ease of input.
	
